/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.c
 #	source generated by 4D Plugin Wizard
 #	Project : egkreader
 #	author : ab
 #	11.08.17
 #
 # --------------------------------------------------------------------------------*/

#include "4DPluginAPI.h"
#include "4DPlugin.h"


#define __STDC_WANT_LIB_EXT1__ 1
#include <string.h>
#include <stdlib.h>

#include "egkreader.h"

void PluginMain( long selector, PA_PluginParameters params )
{
	switch( selector )
	{
// --- egkreader

		case eCMD_egkreader :
			egkreader( params );
			break;

	}
}

// ----------------------------------- egkreader ----------------------------------


void egkreader( PA_PluginParameters params )
{
	long ccCmd;
    long ccData_len = 0;
	PA_long32 returnValue = 0;
    
    unsigned char ccData[32000];
    memset(ccData, 0, 32000);
    
    ccCmd = PA_GetLongParameter( params, 1 );
    ccData_len = PA_GetBlobParameter(params, 2, 0);
    PA_GetBlobParameter(params, 2, ccData);
    if (ccData_len>0) {
        if (ccData[ccData_len-1] == '\0') {
            ccData_len--;
        }
    }
    returnValue = (PA_long32)DoCC3access(ccCmd, &ccData_len, &(ccData[0]));
    
    if (ccData_len>0) {
        if (ccData[ccData_len-1] == '\0') {
            ccData_len--;
        }
    }
    if (ccData_len>0) {
        for (long i=0; i<ccData_len; i++) {
            if (ccData[i] == '\0') {
                ccData[i] = 0x20;
            }
        }
    }
    
    PA_SetBlobParameter( params, 2, ccData, ccData_len);
	PA_ReturnLong( params, returnValue );
}


long DoCC3access(long cmd, long *pDataLen, unsigned char *pData)
{
    long err = 0;
    char *path;
    static int libmode = '0';
	
    switch(cmd)
    {
        case eCmdOpenCT:
            //open card communication
            path = (char*)malloc(((*pDataLen) + 1) * sizeof(unsigned char));
            memcpy(path, pData, (*pDataLen));
            path[(*pDataLen)] = 0x00;
            err = reader_start(path, libmode);
            free(path);
            break;
            
        case eCmdCloseCT:
            //close communication
            reader_stop();
            break;
            
        case eCmdReadCard:
            // read card
            err = reader_read(pDataLen, pData);
            break;
            
        case eCmdEjectCard:
            //eject card
            err = reader_eject();
            break;
            
        case eCmdEraseBin:
            //erase record
            err = reader_erase();
            break;
            
        case eCmdCardState:
            // get card state
            err = reader_state(pDataLen, pData);
            break;
            
        case eCmdSetLib:
            // set library mode
            if (pDataLen > 0) {
                if ((0x30 <= pData[0]) && (pData[0] <= 0x39))
                    libmode = pData[0];
                else
                    err = -1;
            }
            break;
    }
    return err;
}


